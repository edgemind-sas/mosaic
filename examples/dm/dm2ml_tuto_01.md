
# Table des mati√®res

1.  [Introduction](#introduction)
2.  [Technical prerequisites](#init-env)
3.  [Step 1: choosing indicators](#orga94b9b6)
4.  [Step 2: creating predictive models](#org45b895a)
    1.  [Upward movement](#org375b568)
    2.  [Downward movement](#org6bb81c4)
5.  [Step 3: Creating a decision model](#orgeb34b28)
6.  [Step 4: Fitting the decision model with OHLCV data](#orga96c912)
7.  [Step 5: Predicting buy and sell decisions](#orgbfdacc9)



<a id="introduction"></a>

# Introduction

This tutorial provides a brief introduction to the MOSAIC \`DM2ML\` class. DM2ML stands for "Decision
Model with 2 Machine Learning models". The \`DM2ML\` class represents decision models that consist of
two return prediction models: a buy prediction model and a sell decision model. The objective of
both prediction models is to predict the occurrence of an upward movement of future returns
(typically for the buy model) or a downward movement of future returns (typically for the sell
model).


<a id="init-env"></a>

# Technical prerequisites

The MOSAIC library requires Python version >= 3.10.

It is recommended to use a Python virtual environment to perform this tutorial. Do not hesitate to
use the `pew` manager.

First, install the MOSAIC library in your environment from GitHub:

    pip install https://github.com/edgemind-sas/mosaic.git          

If the installation was successful, you should be able to import the MOSAIC library in a Python
session and display its version: 

    import mosaic
    
    print(mosaic.__version__)

    0.0.40


<a id="orga94b9b6"></a>

# Step 1: choosing indicators

As explained in the introduction, a DM2ML decision model relies on two predictive models, which in
turn rely on indicators to predict future returns movements. 

In this tutorial, we will use the both the [SRI](../indicators/sri.md) and [MFI](../indicators/sri.md) indicators as feature variables for
our predictive models :

    import mosaic.indicator as mid
    
    indic_1 = mid.SRI(length=5)
    indic_2 = mid.MFI(length=5)


<a id="org45b895a"></a>

# Step 2: creating predictive models

We will now define both the predictive models for upward and downward future returns. To do this, we
use the logistic regression model implemented in the \`PMLogit\` class. 


<a id="org375b568"></a>

## Upward movement

In this example, we configure our predictive model to predict upward future returns on a temporal horizon
of 15 time units forward:

    import mosaic.predict_model as mpr
    
    pm_up = mpr.PMLogit(
        returns_horizon=15,
        direction="up",
        threshold=0.00001,
        features=[indic_1, indic_2],
    )

The arguments of the `PMLogit` class are:

-   `returns_horizon`: number of time units to consider for predicting future returns. The increase or
    decrease (depending on the `direction` argument) of future returns is the target variable of our
    model.
-   `direction`: indicates whether the model will predict an increase in future returns (`"up"`) or a
    decrease (`"down"`).
-   `threshold`: absolute variation threshold of returns indicating a future increase or decrease
    (depends on the `direction` parameter).
-   `features`: list of indicators to use as explanatory variables in the logistic regression.


<a id="org6bb81c4"></a>

## Downward movement

We create the downward future returns prediction model based on the same approach as the upward
model. The only difference is that we switch the direction from `"up"` to `"down"`.

    pm_down = mpr.PMLogit(
        returns_horizon=15,
        direction="down",
        threshold=0.00001,
        features=[indic_1, indic_2],
    )


<a id="orgeb34b28"></a>

# Step 3: Creating a decision model

As we are using logistic regression to predict future returns, we need to use a decision model based
on both buy and sell predictive models. In MOSAIC, this means we need to create an instance of the
\`DM2ML\` class as follows:

    import mosaic.decision_model as mdm
    
    dm = mdm.DM2ML(
        pm_buy=pm_up,
        pm_sell=pm_down,
        buy_threshold=0.01,
        sell_threshold=0.01,
        )

This decision model allows you to specify:

-   `pm_buy`: the model to predict buy signals, which is why we set our model to `pm_up`.
-   `pm_sell`: the model to predict sell signals, which is why we set our model to `pm_sell`.
-   `buy_threshold`: the absolute threshold above which a buy signal is generated by the decision model.
-   `sell_threshold`: the absolute threshold above which a sell signal is generated by the decision model.


<a id="orga96c912"></a>

# Step 4: Fitting the decision model with OHLCV data

The decision model we have built consists of both the buy and sell predictive models. Like all
machine learning/statistical models, both models need to be fitted with data. 

First, let's retrieve some historical OHLCV data. We can use the MOSAIC \`ExchangeCCXT\` class to
connect to Binance and fetch the data. 

    import mosaic.trading as mtr
    
    exchange = mtr.ExchangeCCXT(name="binance")
    exchange.connect()

Next, we can use the \`get\_historic\_ohlcv\` method from our \`exchange\` variable to retrieve the
historic BTC/FDUSD data between 2023-10-01 00:00:00 and 2023-10-10 00:00:00 with a 1-second
timeframe:

    ohlcv_fit_df = \
        exchange.get_historic_ohlcv(
            date_start='2023-10-01 00:00:00',
            date_end='2023-10-10 00:00:00',
            symbol='BTC/FDUSD',
            timeframe='1s',
            index="datetime",
            data_dir=".",
            progress_mode=True,
        )

Finally, we can fit the decision model with the OHLCV data:

    dm.fit(ohlcv_fit_df)

Note that you can check the fitting results of the prediction models using their \`bkd\`
attribute. Since the logistic regression model relies on the [Statsmodels library](https://www.statsmodels.org/stable/index.html), the \`bkd\`
attribute is an instance of a Statsmodels class.

Here are the parameters of the buy model:

    print(dm.pm_buy.bkd.summary())

                               Logit Regression Results                           
    ==============================================================================
    Dep. Variable:              ret_15_up   No. Observations:               774223
    Model:                          Logit   Df Residuals:                   774218
    Method:                           MLE   Df Model:                            4
    Date:                Mon, 16 Oct 2023   Pseudo R-squ.:                0.002226
    Time:                        18:26:40   Log-Likelihood:            -5.3370e+05
    converged:                       True   LL-Null:                   -5.3489e+05
    Covariance Type:            nonrobust   LLR p-value:                     0.000
    =================================================================================
                        coef    std err          z      P>|z|      [0.025      0.975]
    ---------------------------------------------------------------------------------
    const            -0.2090      0.005    -40.623      0.000      -0.219      -0.199
    SRI_close_5      -0.1296      0.003    -41.903      0.000      -0.136      -0.123
    SRI_HL_low_5     -0.0263      0.002    -12.206      0.000      -0.030      -0.022
    SRI_HH_high_5     0.0460      0.002     21.309      0.000       0.042       0.050
    MFI_5             0.0011   7.14e-05     15.496      0.000       0.001       0.001
    =================================================================================

And here, the parameters of the sell model:

    print(dm.pm_sell.bkd.summary())

                               Logit Regression Results                           
    ==============================================================================
    Dep. Variable:            ret_15_down   No. Observations:               774223
    Model:                          Logit   Df Residuals:                   774218
    Method:                           MLE   Df Model:                            4
    Date:                Mon, 16 Oct 2023   Pseudo R-squ.:                0.002225
    Time:                        18:26:41   Log-Likelihood:            -5.3371e+05
    converged:                       True   LL-Null:                   -5.3490e+05
    Covariance Type:            nonrobust   LLR p-value:                     0.000
    =================================================================================
                        coef    std err          z      P>|z|      [0.025      0.975]
    ---------------------------------------------------------------------------------
    const             0.2090      0.005     40.625      0.000       0.199       0.219
    SRI_close_5       0.1295      0.003     41.890      0.000       0.123       0.136
    SRI_HL_low_5      0.0262      0.002     12.184      0.000       0.022       0.030
    SRI_HH_high_5    -0.0460      0.002    -21.313      0.000      -0.050      -0.042
    MFI_5            -0.0011   7.14e-05    -15.505      0.000      -0.001      -0.001
    =================================================================================


<a id="orgbfdacc9"></a>

# Step 5: Predicting buy and sell decisions

It is worth noting the `DM2ML` class generates the buy/sell signal following this process:

1.  Compute the buy score from the `pm_buy` model. This score is often interpretable as the probability of having an upward movement of future returns.
2.  Compute the sell score from the `pm_sell` model. This score is often interpretable as the probability of having a downward movement of future returns.
3.  Subtract the sell score from the buy score to obtain the signal score.
4.  If the signal score > buy\_threshold, generate a buy signal.
    If the signal score < -sell\_threshold, generate a sell signal.
    Generate no signal otherwise.

To test our decision model, we will use BTC/FDUSD data between 2023-10-10 00:00:00 and 2023-10-15 00:00:00 with a 1-second
timeframe:

    ohlcv_test_df = \
        exchange.get_historic_ohlcv(
            date_start='2023-10-10 00:00:00',
            date_end='2023-10-15 00:00:00',
            symbol='BTC/FDUSD',
            timeframe='1s',
            index="datetime",
            data_dir=".",
            progress_mode=True,
        )

As the decision is now fitted, we can hence use the `predict` method to generate buy/sell signals. The
following call of `predict` shows the first 50 signals:  

    dm.predict(ohlcv_test_df.head(50))

                              signal     score
    datetime                                  
    2023-10-10 02:00:00+02:00    NaN       NaN
    2023-10-10 02:00:01+02:00    NaN       NaN
    2023-10-10 02:00:02+02:00    NaN       NaN
    2023-10-10 02:00:03+02:00    NaN       NaN
    2023-10-10 02:00:04+02:00   sell -0.088158
    2023-10-10 02:00:05+02:00   sell -0.029812
    2023-10-10 02:00:06+02:00    NaN  0.003097
    2023-10-10 02:00:07+02:00    NaN -0.006799
    2023-10-10 02:00:08+02:00   sell -0.029812
    2023-10-10 02:00:09+02:00    NaN -0.005031
    2023-10-10 02:00:10+02:00   sell -0.124323
    2023-10-10 02:00:11+02:00   sell -0.072885
    2023-10-10 02:00:12+02:00   sell -0.100467
    2023-10-10 02:00:13+02:00   sell -0.071769
    2023-10-10 02:00:14+02:00    NaN -0.008701
    2023-10-10 02:00:15+02:00   sell -0.115177
    2023-10-10 02:00:16+02:00    buy  0.020245
    2023-10-10 02:00:17+02:00    NaN  0.001313
    2023-10-10 02:00:18+02:00   sell -0.019866
    2023-10-10 02:00:19+02:00   sell -0.020398
    2023-10-10 02:00:20+02:00   sell -0.019923
    2023-10-10 02:00:21+02:00   sell -0.019923
    2023-10-10 02:00:22+02:00   sell -0.029812
    2023-10-10 02:00:23+02:00    NaN -0.006799
    2023-10-10 02:00:24+02:00   sell -0.019923
    2023-10-10 02:00:25+02:00    NaN -0.007408
    2023-10-10 02:00:26+02:00   sell -0.102444
    2023-10-10 02:00:27+02:00   sell -0.085825
    2023-10-10 02:00:28+02:00   sell -0.080609
    2023-10-10 02:00:29+02:00   sell -0.058168
    2023-10-10 02:00:30+02:00   sell -0.014324
    2023-10-10 02:00:31+02:00   sell -0.120801
    2023-10-10 02:00:32+02:00   sell -0.098934
    2023-10-10 02:00:33+02:00   sell -0.048241
    2023-10-10 02:00:34+02:00    buy  0.039185
    2023-10-10 02:00:35+02:00    NaN  0.009713
    2023-10-10 02:00:36+02:00   sell -0.071222
    2023-10-10 02:00:37+02:00   sell -0.079574
    2023-10-10 02:00:38+02:00   sell -0.051199
    2023-10-10 02:00:39+02:00   sell -0.140459
    2023-10-10 02:00:40+02:00   sell -0.067380
    2023-10-10 02:00:41+02:00   sell -0.079823
    2023-10-10 02:00:42+02:00   sell -0.113857
    2023-10-10 02:00:43+02:00   sell -0.076398
    2023-10-10 02:00:44+02:00   sell -0.097717
    2023-10-10 02:00:45+02:00   sell -0.106381
    2023-10-10 02:00:46+02:00   sell -0.154789
    2023-10-10 02:00:47+02:00   sell -0.017929
    2023-10-10 02:00:48+02:00   sell -0.016327
    2023-10-10 02:00:49+02:00   sell -0.057891

Remarks:

-   The first 5 signals are `NaN` because the maximum length of data required to compute the
    indicators is 5.
-   Other `NaN` values correspond to cases when the absolute signal score is below both the buy
    threshold and the sell threshold.

